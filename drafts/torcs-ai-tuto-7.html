<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="https://godidier.github.io/theme/css/style.less">
  <script src="//cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="icon" type="image/vnd.microsoft.icon" href="https://godidier.github.io/">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/normalize.css">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/style.min.css">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Roboto+Mono">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/fontawesome-all.min.css">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/hatena-bookmark-icon.css">
  <link rel="stylesheet" type="text/css" href="/static/custom.css">


  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Didier Gohourou">
  <meta name="description" content="Posts and writings by Didier Gohourou">


<meta name="keywords" content="">

  <title>
    [GTR]
&ndash; Building a Simple TORCS AI Agent (7/11): Collision avoidance and Overtaking  </title>

</head>

<body>
  <main>
    <header>
      <div class="site-name">
        <a href="https://godidier.github.io">[GTR]  <br/> Godidier's Technical Report</a>
      </div>
      <p>
	  <!--
        <a href="https://godidier.github.io/archives.html"><i class="fas fa-archive"></i> Archive</a>
	  -->
      </p>
	  <ul class="menuitems">   
          <li><a href="https://godidier.github.io/">Home</a></li>
          <li><a href="https://godidier.github.io/categories.html">Categories</a></li>
          <li class="menupage"><a href="https://godidier.github.io/pages/about.html">About</a></li>
	  </ul>
    </header>

<article>
  <div class="article__title">
    <h1><a href="https://godidier.github.io/drafts/torcs-ai-tuto-7.html">Building a Simple TORCS AI Agent (7/11): Collision avoidance and Overtaking</a></h1>
  </div>
  <div class="article__meta">
    <p class="article__meta__post-date">Posted on: 水 12 12月 2018</p>
    </p>
  </div>
  <div class="article__text">
    <ul>
<li><a href="https://godidier.github.io/torcs-ai-tuto-1.html#table_of_contents">Table of Contents</a></li>
<li><a href="https://godidier.github.io/drafts/torcs-ai-tuto-6.html">Previous: Recovering</a></li>
<li><a href="https://godidier.github.io/drafts/torcs-ai-tuto-8.html">Next: Pit Stops</a></li>
</ul>
<p>This chapter will describe an approach to implement avoidance and overtaking 
of opponents in a race. There are plenty of ways to do it. Here we will 
present a simple one, meaning you are free to improve it or rethink the 
whole thing.</p>
<p>We start by collecting race information about our opponents, and use that 
information to avoid them and/or overtake them.</p>
<h1>Collecting Opponent's data</h1>
<p>Let's create an opponent class that will hold data for a given opponent 
relative to our AI agent (eg. the distance between that opponent and our AI 
agent). For simplicity we will that class will also hold data which depends 
only on a given opponent, and can be computed independently of our AI agent
(eg. the speed of a given opponent). </p>
<p>Our approach is a bit inefficient because in future chapters, as we will 
learn to run multiple instances of our robot, base on the same code called 
module, some of those variables that are computed independently of our AI 
agent will be recomputed unecessarely by each instance of our robot module.
It will be better to put such calculation in an other class visible by 
all the AI agents of our module. Anyway this is no time to ponder on this 
problem. We didn't even talked about this module thing right?! This is for 
coming chapters. </p>
<p>Create a header file named <em>opponent.h</em> that will contain the declaration 
of the <code>Opponent</code> class we just talked about and of the <code>Opponents</code> class 
that is hold a collection of <code>Opponent</code>s.</p>
<h2>The Opponent Class</h2>
<div class="highlight"><pre><span></span><code><span class="cp">#ifndef _OPPONENT_H_</span>
<span class="cp">#define _OPPONENT_H_</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;math.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;tgf.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;track.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;car.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;raceman.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;robottools.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;robot.h&gt;</span><span class="cp"></span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;linalg/vector2d.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;carcontroller.h&quot;</span><span class="cp"></span>

<span class="cp">#define OPP_IGNORE  0</span>
<span class="cp">#define OPP_FRONT   (1&lt;&lt;0)</span>
<span class="cp">#define OPP_BACK    (1&lt;&lt;1)</span>
<span class="cp">#define OPP_SIDE    (1&lt;&lt;2)</span>
<span class="cp">#define OPP_COLL    (1&lt;&lt;3)</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CarController</span><span class="p">;</span><span class="w"></span>

<span class="cm">/**</span>
<span class="cm"> * Class encapsulating data of our AI agent opponents.</span>
<span class="cm"> */</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Opponent</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">Opponent</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetCar</span><span class="p">(</span><span class="n">tCarElt</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">car</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">SetTrack</span><span class="p">(</span><span class="n">tTrack</span><span class="w"> </span><span class="o">*</span><span class="n">track</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">Opponent</span><span class="o">::</span><span class="n">track</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">track</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">GetSpeed</span><span class="p">(</span><span class="n">tCarElt</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">tCarElt</span><span class="w"> </span><span class="o">*</span><span class="nf">GetCar</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">car</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">GetState</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="nf">GetCatchDistance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">catch_distance</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="nf">GetDistance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">distance</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="nf">GetSideDistance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">side_distance</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="nf">GetWidth</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="nf">GetSpeed</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">speed</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">Update</span><span class="p">(</span><span class="n">tSituation</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">CarController</span><span class="w"> </span><span class="o">*</span><span class="n">car_controller</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">GetDistanceToSegmentStart</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="n">tCarElt</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="p">;</span><span class="w">       </span><span class="cm">/* pointer to the opponents car */</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">distance</span><span class="p">;</span><span class="w">     </span><span class="cm">/* approximation of the real distance */</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">speed</span><span class="p">;</span><span class="w">        </span><span class="cm">/* speed in direction of the track */</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">catch_distance</span><span class="p">;</span><span class="w">    </span><span class="cm">/* distance needed to catch the opponent */</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">width</span><span class="p">;</span><span class="w">        </span><span class="cm">/* the cars needed width on the track */</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">side_distance</span><span class="p">;</span><span class="w">     </span><span class="cm">/* distance of center of gravity of the cars */</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="p">;</span><span class="w">          </span><span class="cm">/* state bitmask of the opponent */</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* class variables */</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="n">tTrack</span><span class="w"> </span><span class="o">*</span><span class="n">track</span><span class="p">;</span><span class="w"></span>

<span class="w">        </span><span class="cm">/* constants */</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">FRONT_COLLDIST</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">BACK_COLLDIST</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">SIDE_COLLDIST</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">LENGTH_MARGIN</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">WIDTH_MARGIN</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>


<span class="cm">/** </span>
<span class="cm"> * Holds an array of Opponents our AI agent is racing against</span>
<span class="cm"> **/</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Opponents</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">Opponents</span><span class="p">(</span><span class="n">tSituation</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">CarController</span><span class="w"> </span><span class="o">*</span><span class="n">car_controller</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="o">~</span><span class="n">Opponents</span><span class="p">();</span><span class="w"></span>

<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">Update</span><span class="p">(</span><span class="n">tSituation</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">CarController</span><span class="w"> </span><span class="o">*</span><span class="n">car_controller</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">Opponent</span><span class="w"> </span><span class="o">*</span><span class="nf">GetOpponentPtr</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">opponent</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="nf">Count</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"> </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="n">Opponent</span><span class="w"> </span><span class="o">*</span><span class="n">opponent</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w"></span>
<span class="p">};</span><span class="w"></span>

<span class="cp">#endif _OPPONENT_H_</span>
</code></pre></div>

<p>The code start by including the necessary header, then define bitmasks 
aliases that will be useful to classify opponents. There is also a 
<code>CarController</code> class prototype declaration, because of the cross dependency 
[Of what? be more assertive]. 
After that we can declare the <code>Opponent</code> class, that mainly contains values 
and 'getters' of the information we want to hold.
Finally, we declare the <code>Opponents</code> class that hold an array of <code>Opponent</code>s 
characterized by and <code>Opponent</code> pointer (the address of the array), and the 
number of opponents we are dealing with.</p>
<p>Now create a file named <em>opponent.cpp</em> where we will define the symbols we just 
declared.</p>
<p>We start by including the header and define the class variables and constants. </p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opponent.h&quot;</span><span class="cp"></span>

<span class="n">tTrack</span><span class="o">*</span><span class="w"> </span><span class="n">Opponent</span><span class="o">::</span><span class="n">track</span><span class="p">;</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">Opponent</span><span class="o">::</span><span class="n">FRONT_COLLDIST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">200.0</span><span class="p">;</span><span class="w">  </span><span class="cm">/* [m] distance to check for other cars */</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">Opponent</span><span class="o">::</span><span class="n">BACK_COLLDIST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">50.0</span><span class="p">;</span><span class="w">    </span><span class="cm">/* [m] distance to check for other cars */</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">Opponent</span><span class="o">::</span><span class="n">LENGTH_MARGIN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w">    </span><span class="cm">/* [m] safety margin */</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="n">Opponent</span><span class="o">::</span><span class="n">WIDTH_MARGIN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w">      </span><span class="cm">/* [m] safety margin */</span><span class="w"></span>
</code></pre></div>

<p><code>FRONT_COLLDIST</code> and <code>BACK_COLLDIST</code> respectively define distances from which 
our AI agent will start checking for collision at the front and at the back.
<code>LENGTH_MARGIN</code> and <code>WIDTH_MARGIN</code> are safety margins respectively on the 
length and width axis of our AI agent's car as minimal distance we would like 
to maintain to our opponents. You can go further and put those parameters in 
an XML setup file and load them at startup (...more on loading setups in 
coming chapters). </p>
<p>The following <code>Opponent::GetSpeed(tCarElt *car)</code> method computes the speed of 
the car in the direction of the track. We first get the direction of the track 
at the cars location. After that, we compose the speed vector of the car. 
We use <code>_speed_X</code> and <code>_speed_Y</code> here, the uppercase X and Y means that the 
speed vector is in global coordinates, the lowercase x and y are the speeds 
in the <em>"instantaneously coincident frame of reference"</em>, a coordinate system 
that is oriented like the cars body but doesn't move with the car (if it 
would move with the car the <code>_speed_x</code> and <code>_speed_y</code> would always be zero). 
From the trackangle we compute a direction vector of the track 
(its length is one). Finally we compute the dot product of the speed and the 
direction, which will give us the speed in the direction of the track. </p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Compute speed component parallel to the track </span>
<span class="cm"> **/</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">Opponent::GetSpeed</span><span class="p">(</span><span class="n">tCarElt</span><span class="w"> </span><span class="o">*</span><span class="n">car</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">speed</span><span class="p">,</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">track_angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">RtTrackSideTgAngleL</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">));</span><span class="w"></span>

<span class="w">    </span><span class="n">speed</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_X</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">speed</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_Y</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">direction</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">track_angle</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">direction</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">track_angle</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>The next method <code>Opponent::getDistToSegStart()</code>  computes the distance of the 
opponent to the segments start. The reason is that <code>car-&gt;_trkPos.toStart</code> 
contains the length of the segment for straight segments and for turns the 
arc, so we need a conversion to the length.</p>
<div class="highlight"><pre><span></span><code><span class="cm">/** </span>
<span class="cm"> * Compute the length to the start of the segment </span>
<span class="cm"> **/</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">Opponent::GetDistanceToSegmentStart</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TR_STR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toStart</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toStart</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">radius</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Now we will have a look at the 
<code>Opponent::Update(tSituation *s, CarController *car_controller)</code> 
function that is responsible for the update of the values in the Opponent 
instances.  </p>
<p>First we get a pointer to our AI agent controller, that we name <code>agent</code>. 
We set the initial state to ignore the current opponent. We then check if 
the opponent's car is not longer part of the simulation. We do that using 
<code>RM_CAR_STATE_NO_SIMU</code> which is a car state flag defined in 
<em>$TORCS_BASE/src/interfaces/car.h</em>, that indicate if a car is simulated 
or not.</p>
<p>Next, we compute the distance of the center of the agent car (our car), to the 
center of the current opponent car. We achieve that by computing the distances 
to the start line and taking the difference. Our calculation is approximating 
the real distance. For a more accurate value, we have to compute it with the 
cars corners (look up car.h). The <code>if</code> part is to "normalize" the distance. 
Note that from the position of our agent up to a the half track length, the 
opponent is in front of us (<code>distance</code> is positive). Otherwise, the opponent 
is behind (<code>distance</code> is negative). A detail is that we can't use 
<code>_distFromStartLine</code>, an alias of <code>race.distFromStartLine</code> in car.h of the 
opponent, because it is a private field [??]. </p>
<p>We update the speed with the previously introduced <code>GetSpeed()</code> method. Then we 
compute the width of the opponents car on the track (think the car is turned 90 
degrees on the track, then the needed "width" is its length). </p>
<p>Then, we check if the opponent is in the range we defined as relevant. After 
that, the classification of the opponent starts. In this part we check if it is 
in front of us and slower. If that is the case we compute the distance we need 
to drive to catch the opponent (catchdist, we assume the speeds are constant) 
and set the opponents flag <code>OPP_FRONT</code>. Because the "distance" contains the 
value of the cars centers we need to subtract a car length and the safety 
margin. At the end we check if we could collide with to opponent. If yes, 
we set the flag <code>OPP_COLL</code>. </p>
<p>Here we check if the opponent is behind us and faster. We won't use that 
in the tutorial robot, but you will need it if you want to let overlap 
faster opponents. </p>
<p>This part is responsible to check if the opponent is aside of us. If yes,
we compute the distance (sideways) and set the flag <code>OPP_SIDE</code>. </p>
<div class="highlight"><pre><span></span><code><span class="cm">/** </span>
<span class="cm"> * Update the values in Opponent this </span>
<span class="cm"> **/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Opponent::Update</span><span class="p">(</span><span class="n">tSituation</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">CarController</span><span class="w"> </span><span class="o">*</span><span class="n">car_controller</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tCarElt</span><span class="w"> </span><span class="o">*</span><span class="n">agent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car_controller</span><span class="o">-&gt;</span><span class="n">GetCar</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* init state of opponent to ignore */</span><span class="w"></span>
<span class="w">    </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OPP_IGNORE</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* if the car is out of the simulation ignore it */</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_state</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">RM_CAR_STATE_NO_SIMU</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* updating distance along the middle */</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">oppToStart</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">lgfromstart</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">GetDistanceToSegmentStart</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="n">distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oppToStart</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">agent</span><span class="o">-&gt;</span><span class="n">_distFromStartLine</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">distance</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">track</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">distance</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">track</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">-</span><span class="n">track</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">distance</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">track</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* update speed in track direction */</span><span class="w"></span>
<span class="w">    </span><span class="n">speed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Opponent</span><span class="o">::</span><span class="n">GetSpeed</span><span class="p">(</span><span class="n">car</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cosa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">speed</span><span class="o">/</span><span class="n">sqrt</span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_X</span><span class="o">*</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_Y</span><span class="o">*</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_Y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">alpha</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">acos</span><span class="p">(</span><span class="n">cosa</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_dimension_x</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_dimension_y</span><span class="o">*</span><span class="n">cosa</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">SIDECOLLDIST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">MIN</span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_dimension_x</span><span class="p">,</span><span class="w"> </span><span class="n">agent</span><span class="o">-&gt;</span><span class="n">_dimension_x</span><span class="p">);</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* is opponent in relevant range -50..200 m */</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">-</span><span class="n">BACK_COLLDIST</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">FRONT_COLLDIST</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* is opponent in front and slower */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">distance</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">SIDECOLLDIST</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">car_controller</span><span class="o">-&gt;</span><span class="n">GetSpeed</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">catch_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car_controller</span><span class="o">-&gt;</span><span class="n">GetSpeed</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">distance</span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">car_controller</span><span class="o">-&gt;</span><span class="n">GetSpeed</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">speed</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">OPP_FRONT</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">distance</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">MAX</span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_dimension_x</span><span class="p">,</span><span class="w"> </span><span class="n">agent</span><span class="o">-&gt;</span><span class="n">_dimension_x</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">distance</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">LENGTH_MARGIN</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">cardist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toMiddle</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">agent</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toMiddle</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">side_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cardist</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">cardist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fabs</span><span class="p">(</span><span class="n">cardist</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">fabs</span><span class="p">(</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">agent</span><span class="o">-&gt;</span><span class="n">_dimension_y</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">cardist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">WIDTH_MARGIN</span><span class="p">)</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">OPP_COLL</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">-</span><span class="n">SIDECOLLDIST</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">speed</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">car_controller</span><span class="o">-&gt;</span><span class="n">GetSpeed</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="cm">/* is opponent behind and faster */</span><span class="w"></span>
<span class="w">            </span><span class="n">catch_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car_controller</span><span class="o">-&gt;</span><span class="n">GetSpeed</span><span class="p">()</span><span class="o">*</span><span class="n">distance</span><span class="o">/</span><span class="p">(</span><span class="n">speed</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">car_controller</span><span class="o">-&gt;</span><span class="n">GetSpeed</span><span class="p">());</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">OPP_BACK</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">distance</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">MAX</span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_dimension_x</span><span class="p">,</span><span class="w"> </span><span class="n">agent</span><span class="o">-&gt;</span><span class="n">_dimension_x</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="n">distance</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">LENGTH_MARGIN</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">distance</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">-</span><span class="n">SIDECOLLDIST</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SIDECOLLDIST</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="cm">/* is opponent aside */</span><span class="w"></span>
<span class="w">            </span><span class="n">side_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toMiddle</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">agent</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toMiddle</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">state</span><span class="w"> </span><span class="o">|=</span><span class="w"> </span><span class="n">OPP_SIDE</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Now the implementation of the <code>Opponents</code> class methods.</p>
<p>First the constructor. The constructor allocates memory and generates the 
Opponent instances. The destructor deletes the instances and frees the memory. </p>
<div class="highlight"><pre><span></span><code><span class="cm">/** </span>
<span class="cm"> * Initialize the list of opponents </span>
<span class="cm"> **/</span><span class="w"></span>
<span class="n">Opponents</span><span class="o">::</span><span class="n">Opponents</span><span class="p">(</span><span class="n">tSituation</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">CarController</span><span class="w"> </span><span class="o">*</span><span class="n">car_controller</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">opponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Opponent</span><span class="p">[</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">_ncars</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">];</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">_ncars</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cars</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">car_controller</span><span class="o">-&gt;</span><span class="n">GetCar</span><span class="p">())</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">opponent</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">SetCar</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">cars</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span><span class="w"></span>
<span class="w">            </span><span class="n">j</span><span class="o">++</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">Opponent</span><span class="o">::</span><span class="n">SetTrack</span><span class="p">(</span><span class="n">car_controller</span><span class="o">-&gt;</span><span class="n">GetTrack</span><span class="p">());</span><span class="w"></span>
<span class="w">    </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">_ncars</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Then the <code>Opponents::Update</code></p>
<div class="highlight"><pre><span></span><code><span class="n">Opponents</span><span class="o">::~</span><span class="n">Opponents</span><span class="p">()</span><span class="w"> </span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="n">opponent</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<h2>Modifying our AI agent controller</h2>
<p>Let's add the missing methods to access some data of our car controller 
class from the opponent class.</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> *  Updates all the Opponent instances </span>
<span class="cm"> **/</span><span class="w"></span>
<span class="kt">void</span><span class="w"> </span><span class="nf">Opponents::Update</span><span class="p">(</span><span class="n">tSituation</span><span class="w"> </span><span class="o">*</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">CarController</span><span class="w"> </span><span class="o">*</span><span class="n">car_controller</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">s</span><span class="o">-&gt;</span><span class="n">_ncars</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Update</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">car_controller</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<h2>Updating the Makefile</h2>
<p>Add the <code>Opponent</code> class to the compilation configuration by adding 
'<em>opponent.cpp</em>' to the <code>SOURCES</code> variables in the <em>Makefile</em></p>
<div class="highlight"><pre><span></span><code>SOURCES     = <span class="cp">${</span><span class="n">ROBOT</span><span class="cp">}</span>.cpp carcontroller.cpp opponent.cpp
</code></pre></div>

<p>[Test Drive + Video ?]</p>
<h1>Collision Avoidance</h1>
<p>Our agent will handle two cases of collision avoidance: front collision and 
side collision. Diffent commands are applied to handle each one of them. 
In this section we implement two basic approaches to avoid collisions 
according to the situation (the type of collision we want to avoid).</p>
<h2>Avoiding Front Collision</h2>
<p>A front collision is the case where the front part of our AI agent's car hits 
an opponent's car at it's back. We will avoid this type of collision by 
adding an additional filter to our braking mechanism.</p>
<p>First, let's add the necessary declaration to our <code>CarController</code> class. 
We include the <em>opponent.h</em> header and add the forward-declaration of 
the <code>Opponent</code> and <code>Opponents</code> classes. We also add a destructor, 
declare the braking filter method in the public section of the class, and 
an <code>Opponents</code> and <code>Opponent</code> pointers to hold the list of opponents and 
the current opponent we will analyze at a given time.</p>
<div class="highlight"><pre><span></span><code><span class="c1">//... Other includes</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;opponent.h&quot;</span><span class="cp"></span>

<span class="c1">//...</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Opponents</span><span class="p">;</span><span class="w"></span>
<span class="k">class</span><span class="w"> </span><span class="nc">Opponent</span><span class="p">;</span><span class="w"></span>

<span class="k">class</span><span class="w"> </span><span class="nc">CarController</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="o">~</span><span class="n">CarController</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="c1">//...</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">FilterBrakeCollision</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">brake</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">//...</span>
<span class="w">        </span><span class="n">Opponents</span><span class="w"> </span><span class="o">*</span><span class="n">opponents</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Opponent</span><span class="w"> </span><span class="n">opponent</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Now to the implementation in <em>carcontroller.cpp</em>. We define the destructor.</p>
<div class="highlight"><pre><span></span><code><span class="n">CarController</span><span class="o">::~</span><span class="n">CarController</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="k">delete</span><span class="w"> </span><span class="n">opponents</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Instantiate the <code>Opponent</code>(s) classes in <code>NewRace</code> method</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">CarController::NewRace</span><span class="p">(</span><span class="n">tCarElt</span><span class="o">*</span><span class="w"> </span><span class="n">car</span><span class="p">,</span><span class="w"> </span><span class="n">tSituation</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">opponents</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Opponents</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="k">this</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="n">opponent</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opponents</span><span class="o">-&gt;</span><span class="n">GetOpponentPtr</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="c1">//...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Let's implement the filter method. In a nutshell it iterates through the 
opponents and checks for every opponent which has been tagged with <code>OPP_COLL</code> 
if we need to brake to avoid a collision. If yes we brake full and leave 
the method. </p>
<p>We set up some variables and then we enter the loop to iterate through all 
opponents. The presented solution is not optimal. You could replace the call to 
<code>GetDistance()</code> with <code>GetChatchDist()</code>, but additional code is necessary to make 
it work. The computation of the brakedistance should be familiar from 
previous chapters. </p>
<div class="highlight"><pre><span></span><code><span class="cm">/** </span>
<span class="cm"> * Filter the brake to avoid a front collision</span>
<span class="cm"> **/</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">CarController::FilterBrakeCollision</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">brake</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">current_speed_sqr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_x</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">mu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">surface</span><span class="o">-&gt;</span><span class="n">kFriction</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">cm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mu</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">full_car_mass</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">ca</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">CA</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mu</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CW</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">opponents</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">){</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GetState</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">OPP_COLL</span><span class="w"> </span><span class="p">){</span><span class="w"></span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">allowed_speed_sqr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GetSpeed</span><span class="p">(),</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">brake_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">full_car_mass</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">current_speed_sqr</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">allowed_speed_sqr</span><span class="p">)</span><span class="w"> </span>
<span class="w">                </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">2.0</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">cm</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">allowed_speed_sqr</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">ca</span><span class="p">));</span><span class="w"> </span>
<span class="w">                </span><span class="k">if</span><span class="p">(</span><span class="n">brake_distance</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GetDistance</span><span class="p">()){</span><span class="w"></span>
<span class="w">                    </span><span class="k">return</span><span class="w"> </span><span class="mf">1.0</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">brake</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Now we can call it in the <code>GetBrake</code> method.</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="nf">CarController::GetBrake</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="n">brake</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FilterABS</span><span class="p">(</span><span class="n">FilterBrakeCollision</span><span class="p">(</span><span class="n">brake</span><span class="p">));</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">brake</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>[Test drive with other robots or driver]</p>
<h2>Avoiding Side Collision</h2>
<p>In this section we add a collision avoidance mechanism for cars that drive 
aside of our car. The following implementation will add an additional filter 
to the steer value. But it doesn't check if we leave the track. </p>
<p>We start with the declaration in <em>carcontroller.h</em>.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CarController</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">SIDE_COLLISION_MARGIN</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">FilterSteeringCollision</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">steering</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>We go in <em>carcontroller.cpp</em> for the definitions. 
The <code>SIDE_COLLISION_MARGIN</code> constant at the beginning. </p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">CarController</span><span class="o">::</span><span class="n">SIDE_COLLISION_MARGIN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"> </span><span class="cm">/* [m] */</span><span class="w"></span>
</code></pre></div>

<p>The <code>FilterSteeringCollision</code> method do an approximate search of the 
nearest car aside of our agent's one, at first. If there is another car it 
checks if it is inside the <code>SIDE_COLLISION_MARGIN</code>. If so, it computes a 
new steer value and returns it. </p>
<p>Concretely, we iterate through all cars and check those which have been 
marked with the <code>OPP_SIDE</code> flag. Among those cars, we select the closest 
one, using <code>min_side_distance</code> to keep the minimum distance between our 
car and another one, and <code>opp</code> a pointer to hold the closest car flagged
with <code>OPP_SIDE</code>. Note: <code>min_side_distance</code> is initialized with the maximum 
float value because we search for the minimum. </p>
<p>If we found an opponent with our search criteria (<code>opp</code> is not null) we check 
if it is inside the margin. To keep the method simple we assumed that our car 
is parallel to the track (which is not true most of the time). </p>
<p>After that, we compute <code>dist</code>, the side distance between our car and the 
closest opponent, without the opponent car's width. If <code>dist</code> is below the 
side collision margin, we compute <code>c</code>, the half of the side collision margin. 
After that, we compute <code>parallel_steering</code> which is the amount of steering to 
apply to drive parallel to the opponent we are trying to avoid. It is 
obtained by normalizing the <code>angle_difference</code> between our car and the 
opponent's. </p>
<p>The value <code>dist / c</code> is used to weight the sum of the normal <code>steering</code> and the 
<code>parallel_steering</code>. The result (steering) value will turn away our car 
from the opponent's when we are near (about to hit) him.</p>
<p>The mechanism described here can be improved with moore accurate distances, 
and also checking if the normal steering value already point away of the 
opponent's car, before further computations.</p>
<p>[TODO: an illustration of the situation]</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Filter the steering to avoid a collision from the side</span>
<span class="cm"> **/</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">CarController::FilterSteeringCollision</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">steering</span><span class="p">){</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">side_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="n">abs_side_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="n">min_side_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FLT_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Opponent</span><span class="w"> </span><span class="o">*</span><span class="n">opp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="cm">/* get the index of the nearest car (o) */</span><span class="w"></span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">opponents</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GetState</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">OPP_SIDE</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">side_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GetSideDistance</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="n">abs_side_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fabs</span><span class="p">(</span><span class="n">side_distance</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">abs_side_distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_side_distance</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">min_side_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">abs_side_distance</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">opp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="cm">/* if there is another car handle the situation */</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min_side_distance</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">opp</span><span class="o">-&gt;</span><span class="n">GetWidth</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="cm">/* near enough */</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">SIDE_COLLISION_MARGIN</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="cm">/* compute angle between cars */</span><span class="w"></span>
<span class="w">            </span><span class="n">tCarElt</span><span class="w"> </span><span class="o">*</span><span class="n">ocar</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp</span><span class="o">-&gt;</span><span class="n">GetCar</span><span class="p">();</span><span class="w"></span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">angle_difference</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ocar</span><span class="o">-&gt;</span><span class="n">_yaw</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_yaw</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">remainder</span><span class="p">(</span><span class="n">angle_difference</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">PI</span><span class="p">);</span><span class="w"></span>
<span class="w">            </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SIDE_COLLISION_MARGIN</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">c</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">dist</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">)</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">parallel_steering</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">angle_difference</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_steerLock</span><span class="p">;</span><span class="w"></span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">steering</span><span class="o">*</span><span class="p">(</span><span class="n">dist</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">2.0</span><span class="o">*</span><span class="w"> </span><span class="n">parallel_steering</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">dist</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">c</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">steering</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">steering</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>We can now use the filter in the <code>GetSteering</code> method. Change the last line to 
the following two.</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="nf">CarController::GetSteering</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">car_angle</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">steering</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">target_angle</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_steerLock</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">FilterSteeringCollision</span><span class="p">(</span><span class="n">steering</span><span class="p">);</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>[Test drive, video]</p>
<h1>Overtaking</h1>
<p>If we race, it is to win! So we have to tell our ai agent how to overtake. 
As usual, the overtaking mechanism we implement here is quite basic. </p>
<p>If there are opponent cars in front ours (flagged with <code>OPP_FRONT</code>), we pick 
the one with the smallest catch up distance, to attempt an overtake.</p>
<p>To overtake an opponent we will add (another) modification to the steering 
value. This is based on modifying the target point used for our trajectory.
Depending on the side we want to pass an opponent, we slightly add an offset 
vector to the target point. This offset is perpendicular to the track tangent. </p>
<p>[TODO: Illustration]</p>
<p>Let's make the necessary declarations in <em>carcontroller.h</em>. </p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CarController</span><span class="w"> </span><span class="p">{</span><span class="w"></span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">BORDER_OVERTAKE_MARGIN</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">OVERTAKE_OFFSET_INCREMENT</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">GetOvertakeOffset</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">overtake_offset</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Then in <em>carcontroller.cpp</em> we define the values of the constants at the 
beginning of the file.</p>
<p><code>BORDER_OVERTAKE_MARGIN</code> is the border relative to the 
<code>FilterTrack(float acceleration)</code> width. It should avoid that we leave the 
range on the track where <code>FilterTrack</code>allows acceleration. 
<code>OVERTAKE_OFFSET_INCREMENT</code> is the increment of the offset value. 
We also lower the value of the <code>WIDTH_DIV</code> constant.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// ...</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">CarController</span><span class="o">::</span><span class="n">WIDTH_DIV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">3.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// [-]</span>
<span class="c1">// ...</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">CarController</span><span class="o">::</span><span class="n">BORDER_OVERTAKE_MARGIN</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.5</span><span class="p">;</span><span class="w"> </span><span class="cm">/* [m] */</span><span class="w"></span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">CarController</span><span class="o">::</span><span class="n">OVERTAKE_OFFSET_INCREMENT</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span><span class="p">;</span><span class="w">    </span><span class="cm">/* [m/timestep] */</span><span class="w"></span>
</code></pre></div>

<p><code>overtake_offset</code> is initialize to zero in the <code>NewRace()</code> method.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">CarController::NewRace</span><span class="p">(</span><span class="n">tCarElt</span><span class="o">*</span><span class="w"> </span><span class="n">car</span><span class="p">,</span><span class="w"> </span><span class="n">tSituation</span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>And here is the implementation of <code>GetOvertakeOffset()</code> that compute the 
offset to the target point.</p>
<p>[More explanation ?]
Now we have a look on how we compute the offset of the target point. </p>
<p>As we discussed earlier, we hold a pointer <code>opp</code> to the car with the smallest 
<code>catch_distance</code> (the one we will reach first), among the car with the 
<code>OPP_FRONT</code> set (in front of us).</p>
<p>In case we found an opponent to overtake (<code>opp</code> is not <code>NULL</code>), we check 
which side of the track that opponent is, and if there is enough space on the 
other side of the track to overtake.</p>
<p>In case we have not found an opponent to overtake, the offset goes back 
slightly toward zero. In the next section we will add the offset to the 
target point. </p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Compute an offset to the trajectory target point for overtaking.</span>
<span class="cm"> * */</span><span class="w"></span>
<span class="kt">float</span><span class="w"> </span><span class="nf">CarController::GetOvertakeOffset</span><span class="p">(){</span><span class="w"></span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">catch_distance</span><span class="p">,</span><span class="w"> </span>
<span class="w">        </span><span class="n">min_catch_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FLT_MAX</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Opponent</span><span class="w"> </span><span class="o">*</span><span class="n">opp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"></span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">opponents</span><span class="o">-&gt;</span><span class="n">Count</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GetState</span><span class="p">()</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">OPP_FRONT</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">            </span><span class="n">catch_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">GetCatchDistance</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">catch_distance</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">min_catch_distance</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">                </span><span class="n">min_catch_distance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">catch_distance</span><span class="p">;</span><span class="w"></span>
<span class="w">                </span><span class="n">opp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">opponent</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="w"></span>
<span class="w">            </span><span class="p">}</span><span class="w"></span>
<span class="w">        </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp</span><span class="o">-&gt;</span><span class="n">GetCar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">WIDTH_DIV</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">BORDER_OVERTAKE_MARGIN</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">opp_to_middle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opp</span><span class="o">-&gt;</span><span class="n">GetCar</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toMiddle</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">opp_to_middle</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">-</span><span class="n">w</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">OVERTAKE_OFFSET_INCREMENT</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">0.0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">w</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">OVERTAKE_OFFSET_INCREMENT</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">OVERTAKE_OFFSET_INCREMENT</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">-=</span><span class="w"> </span><span class="n">OVERTAKE_OFFSET_INCREMENT</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="o">-</span><span class="n">OVERTAKE_OFFSET_INCREMENT</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">OVERTAKE_OFFSET_INCREMENT</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span>
<span class="w">            </span><span class="n">overtake_offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">overtake_offset</span><span class="p">;</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>Finally, we need to add the offset to the target point. We will include the 
calculations that directly into the <code>GetTargetPoint()</code> method. For that, we 
compute a normalized vector at the target point perpendicular to the track 
tangent. We also multiply it with the <code>offset</code> before we adding it to the 
target vector. </p>
<p>Here are the modifications of <code>GetTargetPoint()</code>. The first change is the 
<code>offset</code> variable, initialized with GetOvertakeOffset(). </p>
<p>The <code>tangent_perpendicular</code> holds the normalized vector perpendicular to 
the track tangent at the target point. The computation depends on whether 
the target point is on a straight or a turn. </p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Find a target point ahead of the car toward which the wheels will steer</span>
<span class="cm"> */</span><span class="w"></span>
<span class="n">Vector2D</span><span class="w"> </span><span class="nf">CarController::GetTargetPoint</span><span class="p">()</span><span class="w"></span>
<span class="p">{</span><span class="w"></span>
<span class="w">    </span><span class="n">tTrackSeg</span><span class="o">*</span><span class="w"> </span><span class="n">segment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">seg</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">look_ahead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LOOK_AHEAD_CONST</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">LOOK_AHEAD_FACTOR</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DistanceFromCarToSegmentEnd</span><span class="p">();</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetOvertakeOffset</span><span class="p">();</span><span class="w"></span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">look_ahead</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">segment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">length</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="w">    </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">look_ahead</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">target_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SL</span><span class="p">].</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SR</span><span class="p">].</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">target_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SL</span><span class="p">].</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SR</span><span class="p">].</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">target_x</span><span class="p">,</span><span class="w"> </span><span class="n">target_y</span><span class="p">);</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TR_STR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">tangent_perpendicular_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_EL</span><span class="p">].</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_ER</span><span class="p">].</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">tangent_perpendicular_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_EL</span><span class="p">].</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_ER</span><span class="p">].</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">tangent_perpendicular</span><span class="p">(</span><span class="n">tangent_perpendicular_x</span><span class="p">,</span><span class="w"> </span><span class="n">tangent_perpendicular_y</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">tangent_perpendicular</span><span class="p">.</span><span class="n">Normalize</span><span class="p">();</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">direction_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_EL</span><span class="p">].</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SL</span><span class="p">].</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">direction_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_EL</span><span class="p">].</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SL</span><span class="p">].</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">direction</span><span class="p">(</span><span class="n">direction_x</span><span class="p">,</span><span class="w"> </span><span class="n">direction_y</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tangent_perpendicular</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span><span class="w"></span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">center</span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">arc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">radius</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">arcsign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TR_RGT</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">arc</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">arcsign</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="n">target</span><span class="p">.</span><span class="n">Rotate</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="n">arc</span><span class="p">);</span><span class="w"></span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">tangent_perpendicular</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">center</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">target</span><span class="p">;</span><span class="w"></span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">arcsign</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">offset</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tangent_perpendicular</span><span class="p">;</span><span class="w"></span>
<span class="w">    </span><span class="p">}</span><span class="w"></span>
<span class="p">}</span><span class="w"></span>
</code></pre></div>

<p>[Test drive &amp; video]</p>
<p>[TODO: about camber setting change]</p>
<p>Let me know if you have a different implementation</p>
<ul>
<li><a href="https://godidier.github.io/torcs-ai-tuto-1.html#table_of_contents">Table of Contents</a></li>
<li><a href="https://godidier.github.io/drafts/torcs-ai-tuto-6.html">Previous: Recovering</a></li>
<li><a href="https://godidier.github.io/drafts/torcs-ai-tuto-8.html">Next: Pit Stops</a></li>
</ul>
  </div>

</article>


  </main>
    <footer>
      <div class="author__logo">
          <img src="/images/2019-02/go-chan.png" alt="logo">
      </div>
      <section class="author">
        <div class="author__name">
          <a href="https://godidier.github.io/pages/about.html">Didier Gohourou</a>
          <p></p>
        </div>
        <div class="author__link">
          <ul style="font-size:16px;">
			<li>&#x26AB;</li>
			<li ><a href="archives.html" title="Archives">Archives</a></li>
			<li>&#x26AB;</li>
			<li ><a href="https://godidier.wordpress.com" title="Another blog &#x279A;">Another blog &#x279A;</a></li>
			<li>&#x26AB;</li>
          </ul>
          <ul>
            <li>
              <a href="#" target="_blank" title="facebook">
                <i class="fab fa-facebook-square"></i>
              </a>
            </li>
            <li>
              <a href="https://twitter.com/godidier" target="_blank" title="twitter">
                <i class="fab fa-twitter-square"></i>
              </a>
            </li>
            <li>
              <a href="https://github.com/godidier" target="_blank" title="github">
                <i class="fab fa-github-square"></i>
              </a>
            </li>
            <li>
              <a href="https://www.linkedin.com/in/godidier/" target="_blank" title="linkedin">
                <i class="fab fa-linkedin-square"></i>
              </a>
            </li>
          </ul>
        </div>
      </section>
      <div class="ending-message">
        <p>&copy; Didier Gohourou. Powered by <a href="http://getpelican.com" target="_blank">Pelican</a>, Theme is using <a href="https://github.com/laughk/pelican-hss" target="_blank">HSS</a>. </p>
      </div>
    </footer>
</body>
</html>