<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="https://godidier.github.io/theme/css/style.less">
  <script src="//cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="icon" type="image/vnd.microsoft.icon" href="https://godidier.github.io/favicon.ico">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/normalize.css">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/style.min.css">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Roboto+Mono">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/fontawesome-all.min.css">
  <link rel="stylesheet" type="text/css" href="https://godidier.github.io/theme/css/hatena-bookmark-icon.css">
  <link rel="stylesheet" type="text/css" href="/static/custom.css">


  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Didier Gohourou">
  <meta name="description" content="Posts and writings by Didier Gohourou">


<meta name="keywords" content="">

  <title>
    Didier Gohourou's Blog
&ndash; Create Your First TORCS Racing AI Bot - Part 04: Steering and Trajectory  </title>

</head>

<body>
  <main>
    <header>
      <div class="site-name">
        <a href="https://godidier.github.io">Didier Gohourou's Blog  <!--<br/> Tutorials, Research and Thoughts--></a>
      </div>
      <p>Tutorials, Research and Thoughts</p>
      <p>
      <!--
        <a href="https://godidier.github.io/archives.html"><i class="fas fa-archive"></i> Archive</a>
      -->

      </p>
	    <ul class="menuitems">   
          <li><a href="https://godidier.github.io/">Home</a></li>
          <li><a href="https://godidier.github.io/categories.html">Categories</a></li>
          <li class="menupage"><a href="https://godidier.github.io/pages/about.html">About</a></li>
          <li class="menupage"><a href="https://godidier.github.io/pages/projects.html">Projects</a></li>
          <li class="menupage"><a href="https://godidier.github.io/pages/resume.html">Resume</a></li>
	    </ul>
    </header>

<article>
  <div class="article__title">
    <h1><a href="https://godidier.github.io/torcs-ai-tuto-04.html">Create Your First TORCS Racing AI Bot - Part 04: Steering and Trajectory</a></h1>
  </div>
  <div class="article__meta">
    <p class="article__meta__post-date">Posted on: Tue 11 December 2018</p>
    </p>
  </div>
  <div class="article__text">
    <ul>
<li><a href="https://godidier.github.io/torcs-ai-tuto-00.html#table_of_contents">Table of Contents</a></li>
</ul>
<p>This is the fifth chapter of a tutorial for building an AI agent for the racing 
game TORCS. In this chapter, we improve the steering angle of our AI Agent. We will 
use an heuristic approach to increase the radius of our car's path in turns, 
thus our speed as well.</p>
<h1>Utility classes</h1>
<p>First, let's introduce two classes to simplify our calculations in computing 
steering angles and specific distances. </p>
<h2>The Vector Class</h2>
<p>The first utility class <code>Vector2D</code>, represent a two dimensional vector. It 
implement useful operations that can be applied to a vector such as: addition, 
substraction, scalar multiplication and dot product. Additional implemented 
functions are normalization, rotation around a center and computation of the length 
of the vector.</p>
<p>Let's create a folder named <em>linalg</em> within our project. Within this folder 
create a file named <em>vector2d.h</em>. Implement the following listing in the created 
file.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifndef _VECTOR2D_</span>
<span class="cp">#define _VECTOR2D_</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Vector2D</span><span class="w"> </span>
<span class="p">{</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">        </span><span class="n">Vector2D</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="w">        </span><span class="n">Vector2D</span><span class="o">&amp;</span><span class="w"> </span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">);</span><span class="w">       </span><span class="c1">// assignement</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w">  </span><span class="c1">// addition</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w">                 </span><span class="c1">// negation</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w">  </span><span class="c1">// substraction</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w">   </span><span class="c1">// scalar mutliplication</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span><span class="w"> </span><span class="c1">// dot product</span>
<span class="w">        </span><span class="k">friend</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scalar</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">);</span>


<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="nf">Length</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="kt">void</span><span class="w"> </span><span class="nf">Normalize</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="nf">Distance</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="nf">Cosine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">point1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">point2</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="nf">Rotate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">arc</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">};</span>



<span class="cm">/**</span>
<span class="cm"> * Assignement. assigns the value of src to this</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">&amp;</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">x</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * vector addition. Add *this to src.</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Negation of *this</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2D</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * vector substraction. compute *this - src.</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2D</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Multiply with a scalar</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scalar</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2D</span><span class="p">(</span><span class="n">scalar</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Dot Product</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Multiply a scalar with a vector</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">scalar</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">Vector2D</span><span class="p">(</span><span class="n">scalar</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">scalar</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">src</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Length of the vector</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="n">Length</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Normalize the vector</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="n">Normalize</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">l</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">Length</span><span class="p">();</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">l</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Distance between *this and point</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="n">Distance</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">point</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">pow</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Cosine of the angle between vectors *this-point1 and *this-point2</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="n">Cosine</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">point1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">point2</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">l1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">l2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point2</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l2</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">l1</span><span class="p">.</span><span class="n">Length</span><span class="p">()</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">l2</span><span class="p">.</span><span class="n">Length</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * Rotate the vector by &#39;arc&#39; radians around the point &#39;center&#39;</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">Vector2D</span><span class="o">::</span><span class="n">Rotate</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">arc</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">d</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="k">this</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">center</span><span class="p">;</span><span class="w"> </span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">sina</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sin</span><span class="p">(</span><span class="n">arc</span><span class="p">),</span><span class="w"> </span><span class="n">cosa</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cos</span><span class="p">(</span><span class="n">arc</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">center</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Vector2D</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosa</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sina</span><span class="p">,</span><span class="w"> </span>
<span class="w">                   </span><span class="n">d</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sina</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">cosa</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</code></pre></div>

<h2>The Straight Class</h2>
<p>The second utiliy class <code>Straight</code>, represent some kind of 
<a href="https://en.wikipedia.org/wiki/Euclidean_vector">Euclidean vector</a>.
We will use it to find intersection points among straights, and distances between 
points and straights.</p>
<p>As you might see the <code>Straight</code> class contains two <code>Vector2D</code>. One hold a point 
on the straight and the other the direction.</p>
<p>Let's create a file named <em>straight.h</em> within the <em>linalg</em> folder. Add the 
following code in the newly created file.</p>
<div class="highlight"><pre><span></span><code><span class="cp">#ifndef _STRAIGHT_</span>
<span class="cp">#define _STRAIGHT_</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;vector2d.h&quot;</span>

<span class="cm">/**</span>
<span class="cm"> * Represent an eucludean vector</span>
<span class="cm"> */</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Straight</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">        </span><span class="n">Straight</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
<span class="w">        </span><span class="n">Straight</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">direction_x</span><span class="p">,</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">direction_y</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span>
<span class="w">            </span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">direction</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">direction_x</span><span class="p">;</span><span class="w"> </span>
<span class="w">            </span><span class="n">direction</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">direction_y</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">Straight</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">point</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">direction</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">point</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">point</span><span class="p">;</span>
<span class="w">            </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">direction</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">Intersection</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Straight</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="nf">Distance</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="p">;</span>

<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">point</span><span class="p">;</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * Intersection point *this and s</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="nf">Straight::Intersection</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Straight</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">const</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">direction</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">))</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="n">direction</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">direction</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">point</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">direction</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * Distance of point s from straight *this</span>
<span class="cm"> */</span>
<span class="kr">inline</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="nf">Straight::Distance</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Vector2D</span><span class="w"> </span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span>
<span class="p">{</span>
<span class="w">    </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">d1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">p</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">d3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">d1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">direction</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">d3</span><span class="p">.</span><span class="n">Length</span><span class="p">();</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="c1">// _STRAIGHT_</span>
</code></pre></div>

<h1>Improving the steering</h1>
<p>The new steering approach we will adopt can be explained as follow:
from driving in the middle of the track, we designate a target point ahead of 
the car toward which we point the wheels. This result in greater turn radius 
of the car. The figure below give an idea of what goes on.</p>
<p><img alt="Steering trajectory" src="https://godidier.github.io/images/2019-01/steering-heuristic.png"></p>
<p>Although the overall path of the car will improve greatly, we have to note 
that we are still far away from a good trajectory, since we cannot take a turn 
with the biggest possible radius, starting and ending onthe middle of the track.</p>
<h2>Finding the target point</h2>
<p>To get the target point, we use the position of our car and the geometry of the 
track. We first pick a distance at <code>look_ahead</code> meters from our car. We place a 
point at the middle of the start of the track segment that is at the distance 
we designated (Note in the code you will see below, the abbreviation for the 
four vertices (points) of a track segment:<code>TR_SL</code> for start left coner, <code>TR_SR</code> for 
start right, <code>TR_EL</code> for End Left and <code>TR_ER</code> for end right). If the point 
is on a straight, the target point is formed by adding a scaled direction vector
otherwise, the target point is formed by applying a rotation to the point.</p>
<p>Here is the method to find the target point we add to <em>carcontroller.cpp</em></p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Find a target point ahead of the car toward which the wheels will steer</span>
<span class="cm"> */</span>
<span class="n">Vector2D</span><span class="w"> </span><span class="nf">CarController::GetTargetPoint</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">tTrackSeg</span><span class="o">*</span><span class="w"> </span><span class="n">segment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">seg</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">look_ahead</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">LOOK_AHEAD_CONST</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_x</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">LOOK_AHEAD_FACTOR</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DistanceFromCarToSegmentEnd</span><span class="p">();</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">length</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">look_ahead</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">segment</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="n">length</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span><span class="w">  </span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">look_ahead</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">target_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SL</span><span class="p">].</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SR</span><span class="p">].</span><span class="n">x</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">target_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SL</span><span class="p">].</span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SR</span><span class="p">].</span><span class="n">y</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="o">/</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">target</span><span class="p">(</span><span class="n">target_x</span><span class="p">,</span><span class="w"> </span><span class="n">target_y</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TR_STR</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">direction_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_EL</span><span class="p">].</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SL</span><span class="p">].</span><span class="n">x</span><span class="p">)</span>
<span class="w">            </span><span class="o">/</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">direction_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_EL</span><span class="p">].</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">vertex</span><span class="p">[</span><span class="n">TR_SL</span><span class="p">].</span><span class="n">y</span><span class="p">)</span>
<span class="w">            </span><span class="o">/</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">direction</span><span class="p">(</span><span class="n">direction_x</span><span class="p">,</span><span class="w"> </span><span class="n">direction_y</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">direction</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">length</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">center</span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">center</span><span class="p">.</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">center</span><span class="p">.</span><span class="n">y</span><span class="p">);</span><span class="w">  </span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">arc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">radius</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">arcsign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TR_RGT</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="n">arc</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="n">arcsign</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">Rotate</span><span class="p">(</span><span class="n">center</span><span class="p">,</span><span class="w"> </span><span class="n">arc</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h2>Heading toward the target point</h2>
<p>Let's update the <code>GetSteering()</code> method to steer the wheels toward the target point</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="nf">CarController::GetSteering</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">car_angle</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">float</span><span class="w"> </span><span class="n">target_angle</span><span class="p">;</span>
<span class="w">    </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">target</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">GetTargetPoint</span><span class="p">();</span>

<span class="w">    </span><span class="n">target_angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atan2</span><span class="p">(</span><span class="n">target</span><span class="p">.</span><span class="n">y</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_pos_Y</span><span class="p">,</span><span class="w"> </span><span class="n">target</span><span class="p">.</span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_pos_X</span><span class="p">)</span><span class="w"> </span>
<span class="w">            </span><span class="o">-</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_yaw</span><span class="p">;</span>
<span class="w">    </span><span class="n">target_angle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">remainder</span><span class="p">(</span><span class="n">target_angle</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">*</span><span class="n">PI</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">target_angle</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_steerLock</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h2>Finishing the Implementation</h2>
<p>Let's define the new constants at the start of <em>carcontroller.cpp</em></p>
<div class="highlight"><pre><span></span><code><span class="c1">// ...</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">CarController</span><span class="o">::</span><span class="n">LOOK_AHEAD_CONST</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">17.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// [m]</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">CarController</span><span class="o">::</span><span class="n">LOOK_AHEAD_FACTOR</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.33</span><span class="p">;</span><span class="w"> </span><span class="c1">// [1/s]</span>
</code></pre></div>

<p>We also update <em>carcontroller.h</em> by including the <code>Vector2D</code> header, and 
declaring the new class members.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// ...</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;linalg/vector2d.h&quot;</span>

<span class="c1">// ... </span>
<span class="k">class</span><span class="w"> </span><span class="nc">CarController</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">LOOK_AHEAD_CONST</span><span class="p">;</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">LOOK_AHEAD_FACTOR</span><span class="p">;</span>
<span class="w">        </span><span class="c1">// ...</span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="n">Vector2D</span><span class="w"> </span><span class="n">GetTargetPoint</span><span class="p">();</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div>

<h3>Test Drive</h3>
<p>[times]</p>
<p id="going_faster"></p>
<h1>Going Faster</h1>
<p>We will modify <code>CarController::GetAllowedSpeed(...)</code>, to pass short turns faster. 
We consider short turns, turns with a small angle (see the figure below). 
We will use a heuristic, which is just a an approach to reach an immediate goal 
(going fast in short turns in our case), without worrying too much about 
optimization, logic, or rationality.</p>
<p><img alt="Illustration of short turns in contrast to long turns" src="https://godidier.github.io/torcs-ai-tuto-04.html"></p>
<p>In our heuristic approximation, we take the outside radius of the first segment 
of the turn <code>segment-&gt;radius + segment-&gt;width/2.0</code>, and we divide it by the 
square root of the angle (represented by <code>arc</code>) of the turn. Remember this is 
a heuristic and don't try to make full sense of why it works. An interesting 
advantage of this approach is the growing acceleration toward the end of a turn.</p>
<p>Here is the code of the new version of <code>CarController::GetAllowedSpeed(...)</code>.</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w">  </span><span class="nf">CarController::GetAllowedSpeed</span><span class="p">(</span><span class="n">tTrackSeg</span><span class="o">*</span><span class="w"> </span><span class="n">segment</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TR_STR</span><span class="p">){</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">FLT_MAX</span><span class="p">;</span><span class="w"> </span><span class="c1">// Max float number </span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">arc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span><span class="w"> </span>
<span class="w">        </span><span class="n">tTrackSeg</span><span class="w"> </span><span class="o">*</span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">segment</span><span class="p">;</span>
<span class="w">        </span><span class="k">while</span><span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">arc</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">PI</span><span class="o">/</span><span class="mf">2.0</span><span class="p">){</span>
<span class="w">            </span><span class="n">arc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">arc</span><span class="p">;</span>
<span class="w">            </span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">arc</span><span class="w"> </span><span class="o">/=</span><span class="w"> </span><span class="n">PI</span><span class="o">/</span><span class="mf">2.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// normalizing the turn angle</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">mu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">surface</span><span class="o">-&gt;</span><span class="n">kFriction</span><span class="p">;</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">radius</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">segment</span><span class="o">-&gt;</span><span class="n">width</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">sqrt</span><span class="p">(</span><span class="n">arc</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sqrt</span><span class="p">((</span><span class="n">mu</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">(</span><span class="mf">1.0</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">MIN</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">CA</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mu</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">full_car_mass</span><span class="p">)));</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>[Test drive and times]</p>
<p>Incidentally, this heuristic may lead the car to slightly go off track on some 
turns. We are about to fix that behavior.</p>
<p id="going_faster"></p>
<h1>Staying on the track</h1>
<p>Now let's correct the unwanted behavior the car might have to slightly go off 
track due to the previously implemented heuristic, by introducing a marging around 
the middle of the track. 
We will readjust our acceleration depending whether we are in the inside or the 
outside of a turn. When we are far away form the middle at the outside of a turn, 
we set our acceleration to zero. In contrast when we are inside, we can accelerate 
further, because the centrifugal force pushes the car outside.</p>
<p>Let's add a method that implement that. A filter for our acceleration depending 
on our position on the track.</p>
<div class="highlight"><pre><span></span><code><span class="cm">/**</span>
<span class="cm"> * Acceleration filter according to the position on the track, </span>
<span class="cm"> * to keep the car on the track.</span>
<span class="cm"> */</span>
<span class="kt">float</span><span class="w"> </span><span class="nf">CarController::FilterTrack</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">acceleration</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">tTrackSeg</span><span class="o">*</span><span class="w"> </span><span class="n">seg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">seg</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_speed_x</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">MAX_UNSTUCK_SPEED</span><span class="p">)</span><span class="w"> </span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">acceleration</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TR_STR</span><span class="p">){</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">to_middle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fabs</span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toMiddle</span><span class="p">);</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">safe_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">WIDTH_DIV</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">to_middle</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">safe_width</span><span class="p">)</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">        </span><span class="k">else</span><span class="w"> </span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">acceleration</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">sign</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">TR_RGT</span><span class="p">)</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toMiddle</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">sign</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mf">0.0</span><span class="p">){</span><span class="w"> </span><span class="c1">// inside a turn</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">acceleration</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">to_middle</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fabs</span><span class="p">(</span><span class="n">car</span><span class="o">-&gt;</span><span class="n">_trkPos</span><span class="p">.</span><span class="n">toMiddle</span><span class="p">);</span>
<span class="w">            </span><span class="kt">float</span><span class="w"> </span><span class="n">safe_width</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">seg</span><span class="o">-&gt;</span><span class="n">width</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">WIDTH_DIV</span><span class="p">;</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">to_middle</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">safe_width</span><span class="p">)</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="mf">0.0</span><span class="p">;</span>
<span class="w">            </span><span class="k">else</span><span class="w"> </span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">acceleration</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>We define the newly added constant at the top of <em>carcontroller.cpp</em> .</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">CarController</span><span class="o">::</span><span class="n">WIDTH_DIV</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">4.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// [-]</span>
<span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">CarController</span><span class="o">::</span><span class="n">MAX_UNSTUCK_SPEED</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.0</span><span class="p">;</span><span class="w"> </span><span class="c1">// [m/s]</span>
</code></pre></div>

<p>WIDTH_DIV is a constant by which we divide the width of the track to get a safe 
width, and MAX_UNSTUCK_SPEED is a speed limit (it will also be useful in coming 
chapter). </p>
<p>We apply the filter at the end of the <code>CarController::GetAcceleration()</code> method, 
before <code>FilterTCL</code> is applied.</p>
<div class="highlight"><pre><span></span><code><span class="kt">float</span><span class="w"> </span><span class="nf">CarController::GetAcceleration</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// ...</span>
<span class="w">    </span><span class="n">acceleration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FilterTrack</span><span class="p">(</span><span class="n">acceleration</span><span class="p">);</span>
<span class="w">    </span><span class="n">acceleration</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FilterTCL</span><span class="p">(</span><span class="n">acceleration</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">acceleration</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>We can finally declare the new methods and constants in <em>carcontroller.h</em>.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CarController</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">public</span><span class="o">:</span><span class="w"> </span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">WIDTH_DIV</span><span class="p">;</span>
<span class="w">        </span><span class="k">static</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">float</span><span class="w"> </span><span class="n">MAX_UNSTUCK_SPEED</span><span class="p">;</span>

<span class="w">    </span><span class="k">private</span><span class="o">:</span>
<span class="w">        </span><span class="c1">// ...</span>
<span class="w">        </span><span class="kt">float</span><span class="w"> </span><span class="n">FilterTrack</span><span class="p">(</span><span class="kt">float</span><span class="w"> </span><span class="n">acceleration</span><span class="p">);</span>

<span class="w">        </span><span class="c1">// ...</span>
<span class="p">};</span>
</code></pre></div>

<p>[Test drive and Time]</p>
<p>Our AI agent start to be competitive right? </p>
<h1>A quick discussion on trajectories</h1>
<p>I can almost hear some of you saying: 
"...Bro, this ai robot trajectory kinda suck..." </p>
<p>So how can we manage to have great, near perfect trajectory ? How to find the 
optimal trajectory ? Like most people, I am still looking for that. Finding 
a perfect trajectory in three dimensions seems to be a NP problem. NP stands 
for non-deterministic polynomial time, and basically means that we are not sure 
if there is a correct (optimal) solution (in polynomial time), but if it does, 
we can make sure of it fairly quickly. A solution in 2D might also work since 
most track are pretty flat. I invite your to search the web for papers or 
other resources about the subject, but here we will discuss approach that 
are not perfect but might work well.</p>
<h2>Heuristic Trajectories</h2>
<p>Like you have seen heuristic means to find a trajectory with some reasonable 
ideas. So we improve our trajectory with adding this and that, improvement x 
causes problem y and so forth... The problem with heuristics is that they may 
work great on some tracks but also horribly fail on some other tracks or dislike 
certain features. You can build quite a good robot with this method, but there 
will be always problems with some track features. </p>
<h2>Geometric Trajectories</h2>
<p>We call a trajectory geometric when it just takes the track geometry into 
account, but doesn't consider the car setup and aerodynamics. 
Some examples include things like curvature linearization, 
cubic <a href="#">splines</a>, 
<a href="https://en.wikipedia.org/wiki/Euler_spiral">clothoid</a>, fitting arcs in the 
turns and other geometric stuff...</p>
<h2>Soft Computing and Machine Learning Approaches</h2>
<p>Soft computing denote techniques that yield (non-perfect) solutions to 
computationally hard tasks, including NP problems. Those approaches are 
tolerant of uncertainty and imprecisions. </p>
<p>Some of the techniques we can use for our AI agent include but are not 
limited to Fuzzy Logic that we can use for appreciating (braking, 
collision) distances, Evolutionary computing that we can combined with 
some geometric approches (e.g. to find splines points in a trajectory), 
we can also use Machine Learning techniques where we can find a lot of 
models we can creatively use to help us find a good racing trajectories.</p>
<ul>
<li><a href="https://godidier.github.io/torcs-ai-tuto-03.html">Previous: Aerodynamics and Stability Controls</a></li>
<li><a href="https://godidier.github.io/drafts/torcs-ai-tuto-05.html">Next: Recovering</a></li>
</ul>
  </div>

</article>


  </main>
    <footer>
      <div class="author__logo">
          <img src="/images/2019-02/go-chan.png" alt="logo">
      </div>
      <section class="author">
        <div class="author__name">
          <a href="https://godidier.github.io/pages/about.html">Didier Gohourou</a>
          <p></p>
        </div>
        <div class="author__link">
          <ul style="font-size:16px;">
			<li>&#x26AB;</li>
			<li ><a href="archives.html" title="Archives">Archives</a></li>
			<li>&#x26AB;</li>
			<li ><a href="https://godidier.wordpress.com" title="Another blog &#x279A;">Another blog &#x279A;</a></li>
			<li>&#x26AB;</li>
          </ul>
          <ul>
            <li>
              <a href="https://twitter.com/godidier" target="_blank" title="twitter">
                <i class="fab fa-twitter-square"></i>
              </a>
            </li>
            <li>
              <a href="https://github.com/godidier" target="_blank" title="github">
                <i class="fab fa-github-square"></i>
              </a>
            </li>
            <li>
              <a href="https://www.linkedin.com/in/godidier/" target="_blank" title="linkedin">
                <i class="fab fa-linkedin-square"></i>
              </a>
            </li>
          </ul>
        </div>
      </section>
      <div class="ending-message">
        <p>&copy; Didier Gohourou. Powered by <a href="http://getpelican.com" target="_blank">Pelican</a>, Theme is using <a href="https://github.com/laughk/pelican-hss" target="_blank">HSS</a>. </p>
      </div>
    </footer>
</body>
</html>